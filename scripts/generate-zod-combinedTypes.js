#! /usr/bin/env node

import chalk from "chalk";
import { Command } from "commander";
import fs from "fs";
import path from "path/posix";
import { generateZodScriptInitialiser } from "./utils/generateZodScriptInitialiser.js";

// Define CLI
const program = new Command()
	.summary("generate combined zod files for pf2ools-schema")
	.description(
		"Generates various TypeScript files from the base Zod types. All `.ts` files in a directory are included, even if they aren't zod declarations. The schema export is assumed to have the same name as its file.",
	)
	.argument("<path>", "Directory")
	.option("-r, --recurse", "Find zod files recursively")
	.option("-e, --exclude <paths...>", "Paths to files or directories that should be excluded")
	.parse(process.argv);

// Collect types to import (if there's a problem it's probably here)
const { relativeFiles, zodDir } = generateZodScriptInitialiser(program);
let contentTypesImportString = "";
const contentTypes = [];
for (const file of relativeFiles) {
	const code = fs.readFileSync(path.join(zodDir, file), { encoding: "utf8" });
	if (code.match(/\nexport const \w+ = contentTemplate(?:\n\t+)?\.extend\(/)) {
		contentTypesImportString += `import { ${path.basename(file, ".ts")} } from "./${file.replace(/\.ts$/, ".js")}";\n`;
		contentTypes.push(path.basename(file, ".ts"));
	}
}

// Define `.refine()` calls on the combined type
const REFINE = `.refine(
	(content) => (content.reference ? (content.reference.type === "reprint" ? true : !!content.data !== !!content.reference.modifications) : content.data),
	"Choose one of \`data\` and \`reference.modifications\` to describe the content.",
);\n`;

// Define the header of each file
const getTSTemplate = (...types) =>
	`// This file was generated by scripts/generate-zod-combinedTypes.js at ${new Date().toUTCString()}\n\nimport { ${[
		"z",
	]
		.concat(types.map((str) => `type ${str}`))
		.join(", ")} } from "zod";\n\n`;

// - Content
fs.writeFileSync(
	`${zodDir}/_content.ts`,
	getTSTemplate().concat(
		contentTypesImportString,
		"\n",
		'export const content = z.discriminatedUnion("type", [',
		"\n\t",
		contentTypes.join(",\n\t"),
		",\n])",
		REFINE,
	),
);
console.log(chalk.green(`Generated ${chalk.italic("content")} type file`));

// - Data
const metaTypes = ["license", "source", "sourceGroup"];
const metaTypesImportString = metaTypes
	.map((type) => {
		const file = relativeFiles.find((file) => file.match(new RegExp(`${type}.ts$`, "i")));
		if (!file) return "";
		return `import { ${type} } from "./${file.replace(/\.ts$/, ".js")}";`;
	})
	.join("\n");
fs.writeFileSync(
	`${zodDir}/_data.ts`,
	getTSTemplate().concat(
		metaTypesImportString,
		"\n\n",
		`const metaType = z.discriminatedUnion("type", [${metaTypes.join(", ")}]);`,
		"\n\n",
		'import { content } from "./_content.js";\n',
		"export const data = content.or(metaType);\n",
	),
);
console.log(chalk.green(`Generated ${chalk.italic("data")} type file`));

// - Bundle
fs.writeFileSync(
	`${zodDir}/_bundle.ts`,
	getTSTemplate("AnyZodObject").concat(
		metaTypesImportString,
		"\n",
		contentTypesImportString,
		"\n",
		`const refineContent = (content: AnyZodObject) =>\n\tcontent${REFINE}`,
		"\n",
		"export const bundle = z.object({",
		"\n\t",
		metaTypes
			.map((type) => `${type}: z.array(${type}).min(1)${type === "source" ? "" : ".optional()"}`)
			.join(",\n\t"),
		",\n\t",
		contentTypes.map((type) => `${type}: z.array(refineContent(${type})).min(1).optional()`).join(",\n\t"),
		",\n});",
		"\n\n",
		'import { nonEmpty } from "./utils/nonEmpty.js";\n',
		"export const anyBundle = bundle.partial().refine(...nonEmpty);\n",
	),
);
console.log(chalk.green(`Generated ${chalk.italic("bundle")} types file`));
